{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../src/Logo.svelte","../../../node_modules/moo/moo.js","../../../src/create-token.js","../../../src/token-utils.js","../../../src/strategies/fetch.js","../../../src/strategies/first.js","../../../src/strategies/limit.js","../../../src/strategies/top.js","../../../src/statement.js","../../../src/strategies/index.js","../../../src/get-statements.js","../../../src/keywords.js","../../../src/index.js","../../node_modules/text-diff/diff.js","../../src/SqlDiff.svelte","../../src/Strategies.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","<a\n  href=\"https://github.com/rickbergfalk/sql-limiter\"\n  class=\"github-corner\"\n  aria-label=\"View source on GitHub\"\n>\n  <svg\n    width=\"80\"\n    height=\"80\"\n    viewBox=\"0 0 250 250\"\n    style=\"fill:#151513; color:#fff; position: absolute; top: 0; border: 0;\n    right: 0;\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n    <path\n      d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6\n      120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3\n      125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n      fill=\"currentColor\"\n      style=\"transform-origin: 130px 106px;\"\n      class=\"octo-arm\"\n    />\n    <path\n      d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6\n      C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0\n      C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1\n      C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4\n      C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9\n      C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5\n      C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9\n      L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n      fill=\"currentColor\"\n      class=\"octo-body\"\n    />\n  </svg>\n</a>\n\n<style>\n  .github-corner:hover .octo-arm {\n    animation: octocat-wave 560ms ease-in-out;\n  }\n  @keyframes octocat-wave {\n    0%,\n    100% {\n      transform: rotate(0);\n    }\n    20%,\n    60% {\n      transform: rotate(-25deg);\n    }\n    40%,\n    80% {\n      transform: rotate(10deg);\n    }\n  }\n  @media (max-width: 500px) {\n    .github-corner:hover .octo-arm {\n      animation: none;\n    }\n    .github-corner .octo-arm {\n      animation: octocat-wave 560ms ease-in-out;\n    }\n  }\n</style>\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","module.exports = {\n  singleSpace() {\n    return {\n      type: \"whitespace\",\n      text: \" \",\n      value: \" \",\n    };\n  },\n  keyword(text) {\n    return {\n      type: \"keyword\",\n      text,\n      value: text.toLowerCase(),\n    };\n  },\n  number(n) {\n    return {\n      type: \"number\",\n      text: `${n}`,\n      value: n,\n    };\n  },\n};\n","function findParenLevelToken(tokens, startingIndex, predicate) {\n  let level = 0;\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (!token) {\n      return null;\n    }\n    if (token.type === \"lparen\") {\n      level++;\n    } else if (token.type === \"rparen\") {\n      level--;\n    } else if (level === 0 && predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction findToken(tokens, startingIndex, predicate) {\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction nextNonCommentNonWhitespace(tokens, startingIndex) {\n  return findToken(\n    tokens,\n    startingIndex,\n    (token) => token.type !== \"whitespace\" && token.type !== \"comment\"\n  );\n}\n\nfunction findLimitInsertionIndex(queryTokens, targetParenLevel) {\n  let level = 0;\n  for (let i = queryTokens.length - 1; i >= 0; i--) {\n    const token = queryTokens[i];\n    if (\n      level === targetParenLevel &&\n      token.type !== \"comment\" &&\n      token.type !== \"whitespace\"\n    ) {\n      return i + 1;\n    }\n\n    if (token.type === \"rparen\") {\n      level++;\n    } else if (token.type === \"lparen\") {\n      level--;\n    }\n  }\n  // This should never happen.\n  // And if it did this lib doesn't know what to do\n  throw new Error(\"Unexpected index\");\n}\n\nmodule.exports = {\n  findParenLevelToken,\n  findToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Determines whether query tokens have \"FETCH\" style limits\n * Postgres, IBM, Actian/Ingres, SQL Server 2012 support this SQL 2008 addition\n *\n * The postgres docs showcase the format nicely:\n * [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n * [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n *\n * For the purposes of sql-limiter, we will look for \"fetch first <number>\" and \"fetch next <number>\"\n * Assuming that whitespace or comments can be between\n *\n * Resources:\n * https://www.postgresql.org/docs/12/sql-select.html\n * https://docs.actian.com/ingres/10s/index.html#page/SQLRef%2FSELECT_Clause.htm%23\n * https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/sqlref/src/tpc/db2z_sql_fetchfirstclause.html\n * https://use-the-index-luke.com/sql/partial-results/top-n-queries\n *\n * @param {array<object>} tokens\n * @param {number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const fetchKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"fetch\"\n  );\n\n  if (!fetchKeywordToken) {\n    return null;\n  }\n\n  let nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    fetchKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (\n    nextNonWC.type !== \"keyword\" ||\n    (nextNonWC.value !== \"next\" && nextNonWC.value !== \"first\")\n  ) {\n    throw new Error(`Unexpected token: ${nextNonWC.type} ${nextNonWC.value}`);\n  }\n\n  nextNonWC = nextNonCommentNonWhitespace(tokens, nextNonWC.index + 1);\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // fetch first was not found, so figure out where it should be inserted\n  // fetch first goes at end before for if that exists. Otherwise before terminator if it exists\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"keyword\" && token.value === \"for\"\n  );\n\n  const fetchToOnlyTokens = [\n    createToken.keyword(\"fetch\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    createToken.singleSpace(),\n    createToken.keyword(\"rows\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"only\"),\n  ];\n\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      ...fetchToOnlyTokens,\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      ...fetchToOnlyTokens,\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    ...fetchToOnlyTokens,\n    ...secondhalf,\n  ];\n}\n\nmodule.exports = {\n  has,\n  add,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the FIRST keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const firstKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"first\"\n  );\n\n  if (!firstKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    firstKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds FIRST to query that does not have it.\n *\n * FIRST is an Actian keyword that operates similar to SQL Server's TOP.\n * TODO - find documentation/examples to figure out if there are any potential edge cases with this solution\n * https://docs.actian.com/vectorhadoop/6.0/#page/SQLLang%2FSELECT_(Interactive).htm%23\n *\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // FIRST was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\nfunction has(tokens, startingIndex) {\n  const limitKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"limit\"\n  );\n\n  if (!limitKeywordToken) {\n    return null;\n  }\n\n  // Supported LIMIT syntaxes\n  // LIMIT <limit_number>                   (most common)\n  // LIMIT <offset_number>,<limit_number>   (supported by ClickHouse)\n\n  const firstNumber = nextNonCommentNonWhitespace(\n    tokens,\n    limitKeywordToken.index + 1\n  );\n\n  if (!firstNumber) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (firstNumber.type !== \"number\") {\n    throw new Error(`Expected number got ${firstNumber.type}`);\n  }\n\n  // Check to see if next non whitespace past first number is a comma\n  // If it is, and that is followed by another number\n  // We are likely dealing with a ClickHouse LIMIT <offset_number>,<limit_number> syntax\n  const possibleComma = nextNonCommentNonWhitespace(\n    tokens,\n    firstNumber.index + 1\n  );\n\n  // If next token doesn't exist, or is not a comma\n  // return the first number as it is the limit\n  if (!possibleComma) {\n    return firstNumber;\n  }\n\n  if (possibleComma.type !== \"comma\") {\n    return firstNumber;\n  }\n\n  // Since we are dealing with \"LIMIT <number> <comma>\" find next number,\n  // as it will be the actual limit for ClickHouse syntax\n  const secondNumber = nextNonCommentNonWhitespace(\n    tokens,\n    possibleComma.index + 1\n  );\n\n  if (!secondNumber) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (secondNumber.type !== \"number\") {\n    throw new Error(`Expected number got ${secondNumber.type}`);\n  }\n\n  return secondNumber;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // Limit was not found, so figure out where it should be inserted\n  // If last keyword is offset, need to put limit before that\n  // If not offset, put limit at end, before terminator if present\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) =>\n      token.type === \"keyword\" &&\n      (token.value === \"offset\" || token.value === \"for\")\n  );\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"limit\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the TOP keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const topKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"top\"\n  );\n\n  if (!topKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    topKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds TOP to query that does not have it.\n *\n * TOP in Actian behaves similar to its FIRST keyword, and SQL Server's TOP (though unclear about its compat with UNION)\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // TOP was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"top\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","/* eslint-disable no-restricted-syntax */\nconst strategies = require(\"./strategies\");\n\nclass Statement {\n  constructor() {\n    this.tokens = [];\n    this.parenLevel = 0;\n    this.targetParenLevel = null;\n    this.statementToken = null;\n    this.fetchToken = null;\n    this.limitToken = null;\n  }\n\n  /**\n   * Returns the statement type keyword in lower case.\n   * If CTE is detected, the first keywords after WITH and AS is returned\n   * @returns string\n   */\n  getStatementType() {\n    if (this.statementToken) {\n      return this.statementToken.value;\n    }\n    return undefined;\n  }\n\n  appendToken(t) {\n    const token = { ...t };\n    token.parenLevel = this.parenLevel;\n    // Index once token is added\n    token.index = this.tokens.length;\n    this.tokens.push(token);\n\n    if (token.type === \"lparen\") {\n      this.parenLevel++;\n    } else if (token.type === \"rparen\") {\n      this.parenLevel--;\n    } else if (token.type === \"keyword\") {\n      // If targetParenLevel has not yet been set,\n      // we are dealing with the first keyword, which informs us of the \"level\"\n      // we want to consider for finding SELECT statments\n      if (this.targetParenLevel === null) {\n        this.targetParenLevel = this.parenLevel;\n      }\n      // Statement keyword we are considering not something found in prep of CTE\n      // If the current keyword isn't a `with` and not `as`, and at the same level as our targetParenLevel,\n      // We can assume it tells us what kind of query we are dealing with.\n      // Consider queries like the following queries\n      //\n      // WITH cte AS (...) SELECT ...\n      // WITH cte AS (...) INSERT INTO ... SELECT\n      // WITH cte AS (...) UPDATE ... FROM ...\n      // (WITH cte AS (...) SELECT ...)\n      if (\n        !this.statementToken &&\n        this.targetParenLevel === this.parenLevel &&\n        token.value !== \"with\" &&\n        token.value !== \"as\"\n      ) {\n        this.statementToken = token;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Array<String>} strategiesToEnforce\n   * @param {Number} limitNumber\n   */\n  enforceLimit(strategiesToEnforce, limitNumber) {\n    const { statementToken, tokens } = this;\n\n    strategiesToEnforce.forEach((s) => {\n      if (!strategies[s]) {\n        throw new Error(`Strategy ${s} not supported`);\n      }\n    });\n\n    if (statementToken && statementToken.value === \"select\") {\n      for (const toEnforce of strategiesToEnforce) {\n        const strategyImplementation = strategies[toEnforce];\n        const numberToken = strategyImplementation.has(\n          tokens,\n          statementToken.index\n        );\n\n        // If number token, check to see if over the limit and reset it if it is\n        // Otherwise return early\n        if (numberToken) {\n          if (parseInt(numberToken.value, 10) > limitNumber) {\n            const firstHalf = tokens.slice(0, numberToken.index);\n            const secondhalf = tokens.slice(numberToken.index + 1);\n            this.tokens = [\n              ...firstHalf,\n              { ...numberToken, text: limitNumber, value: limitNumber },\n              ...secondhalf,\n            ];\n            return;\n          }\n          return;\n        }\n      }\n\n      // An existing limit strategy was not found,\n      // so take the first one in list of strategies to enforce and add it to tokens\n      const preferredStrategy = strategiesToEnforce[0];\n      this.tokens = strategies[preferredStrategy].add(\n        tokens,\n        statementToken.index,\n        statementToken.parenLevel,\n        limitNumber\n      );\n    }\n  }\n\n  toString(stripTerminator = false) {\n    if (stripTerminator) {\n      return this.tokens\n        .filter((t) => t.type !== \"terminator\")\n        .map((t) => t.text)\n        .join(\"\");\n    }\n    return this.tokens.map((token) => token.text).join(\"\");\n  }\n}\n\nmodule.exports = Statement;\n","const fetch = require(\"./fetch\");\nconst first = require(\"./first\");\nconst limit = require(\"./limit\");\nconst top = require(\"./top\");\n\nmodule.exports = {\n  fetch,\n  first,\n  limit,\n  top,\n};\n","const moo = require(\"moo\");\nconst keywords = require(\"./keywords\");\nconst Statement = require(\"./statement\");\n\n// Incoming values will also be compared as lower case to make keyword matching case insensitive\nconst caseInsensitiveKeywords = (defs) => {\n  const defineKeywords = moo.keywords(defs);\n  return (value) => defineKeywords(value.toLowerCase());\n};\n\nconst lexer = moo.compile({\n  whitespace: [\n    /[ \\t]+/u,\n    { match: /\\r\\n/u, lineBreaks: true },\n    { match: /\\n/u, lineBreaks: true },\n  ],\n  // First expression is --line comment, second is /* multi line */\n  comment: [/--.*?$/u, /\\/\\*[^]*?\\*\\//u],\n  lparen: \"(\",\n  rparen: \")\",\n  comma: \",\",\n  period: \".\",\n\n  number: /0|[1-9][0-9]*/u,\n\n  // ; is standard, \\g is a shortcut used in psql and Actian tooling\n  // Are there others?\n  terminator: [\";\", \"\\\\g\"],\n\n  // text == original text\n  // value == value inside quotes\n  quotedIdentifier: [\n    {\n      match: /\".*?\"/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /\\[.*?\\]/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /`.*?`/u,\n      value: (x) => x.slice(1, -1),\n    },\n  ],\n\n  // Updated to allow multi-line strings,\n  // which is allowed by some database drivers (sqlite, actian)\n  // This does not correctly handle escaped doublequotes, however the end result is ok for sql-limiter\n  // Instead of a single string token we get 2 separate string tokens back-to-back\n  string: [\n    {\n      match: /'[^']*'/u,\n      lineBreaks: true,\n    },\n  ],\n\n  // Remaining test is assumed to be an identifier of some kinds (column or table)\n  // UNLESS it matches a keyword case insensitively\n  // The value of these tokens are converted to lower case\n  identifier: [\n    {\n      // This is added to handle non-english identifiers.\n      // This range may be too broad\n      // eslint-disable-next-line no-control-regex\n      match: /(?:\\w|[^\\u0000-\\u007F])+/u,\n      type: caseInsensitiveKeywords({\n        keyword: keywords,\n      }),\n      value: (s) => s.toLowerCase(),\n    },\n  ],\n\n  // Any combination of special characters is to be treated as an operator (as a guess anyways)\n  // Initially these were being noted here but the list is large\n  // and there is no way to know all operators since this supports anything that is SQL-ish\n  operator: {\n    match: /[<>~!@#$%^?&|`*\\-{}+=:/\\\\[\\]]+/u,\n    lineBreaks: false,\n  },\n});\n\n/**\n * Takes SQL text and generates an array of tokens using moo\n * @param {string} sqlText\n */\nfunction getStatements(sqlText) {\n  const statements = [];\n  let statement = new Statement();\n\n  lexer.reset(sqlText);\n  let next = lexer.next();\n\n  while (next) {\n    statement.appendToken(next);\n    if (next.type === \"terminator\") {\n      statements.push(statement);\n      statement = new Statement();\n    }\n    next = lexer.next();\n  }\n  // push last set\n  if (statement.tokens.length) {\n    statements.push(statement);\n  }\n  return statements;\n}\n\nmodule.exports = getStatements;\n","module.exports = [\n  \"absolute\",\n  \"action\",\n  \"ada\",\n  \"add\",\n  \"all\",\n  \"allocate\",\n  \"alter\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"as\",\n  \"asc\",\n  \"assertion\",\n  \"at\",\n  \"authorization\",\n  \"avg\",\n  \"backup\",\n  \"begin\",\n  \"between\",\n  \"bit_length\",\n  \"bit\",\n  \"both\",\n  \"break\",\n  \"browse\",\n  \"bulk\",\n  \"by\",\n  \"cascade\",\n  \"cascaded\",\n  \"case\",\n  \"cast\",\n  \"catalog\",\n  \"char_length\",\n  \"char\",\n  \"character_length\",\n  \"character\",\n  \"check\",\n  \"checkpoint\",\n  \"close\",\n  \"clustered\",\n  \"coalesce\",\n  \"collate\",\n  \"collation\",\n  \"column\",\n  \"commit\",\n  \"compute\",\n  \"connect\",\n  \"connection\",\n  \"constraint\",\n  \"constraints\",\n  \"contains\",\n  \"containstable\",\n  \"continue\",\n  \"convert\",\n  \"corresponding\",\n  \"count\",\n  \"create\",\n  \"cross\",\n  \"current_date\",\n  \"current_time\",\n  \"current_timestamp\",\n  \"current_user\",\n  \"current\",\n  \"cursor\",\n  \"database\",\n  \"date\",\n  \"day\",\n  \"dbcc\",\n  \"deallocate\",\n  \"dec\",\n  \"decimal\",\n  \"declare\",\n  \"default\",\n  \"deferrable\",\n  \"deferred\",\n  \"delete\",\n  \"deny\",\n  \"desc\",\n  \"describe\",\n  \"descriptor\",\n  \"diagnostics\",\n  \"disconnect\",\n  \"disk\",\n  \"distinct\",\n  \"distributed\",\n  \"domain\",\n  \"double\",\n  \"drop\",\n  \"dump\",\n  \"else\",\n  \"end-exec\",\n  \"end\",\n  \"errlvl\",\n  \"escape\",\n  \"except\",\n  \"exception\",\n  \"exec\",\n  \"execute\",\n  \"exists\",\n  \"exit\",\n  \"external\",\n  \"extract\",\n  \"false\",\n  \"fetch\",\n  \"file\",\n  \"fillfactor\",\n  \"first\",\n  \"float\",\n  \"for\",\n  \"foreign\",\n  \"fortran\",\n  \"found\",\n  \"freetext\",\n  \"freetexttable\",\n  \"from\",\n  \"full\",\n  \"function\",\n  \"get\",\n  \"global\",\n  \"go\",\n  \"goto\",\n  \"grant\",\n  \"group\",\n  \"having\",\n  \"holdlock\",\n  \"hour\",\n  \"identity_insert\",\n  \"identity\",\n  \"identitycol\",\n  \"if\",\n  \"immediate\",\n  \"in\",\n  \"include\",\n  \"index\",\n  \"indicator\",\n  \"initially\",\n  \"inner\",\n  \"input\",\n  \"insensitive\",\n  \"insert\",\n  \"int\",\n  \"integer\",\n  \"intersect\",\n  \"interval\",\n  \"into\",\n  \"is\",\n  \"isolation\",\n  \"join\",\n  \"key\",\n  \"kill\",\n  \"language\",\n  \"last\",\n  \"leading\",\n  \"left\",\n  \"level\",\n  \"like\",\n  \"limit\",\n  \"lineno\",\n  \"load\",\n  \"local\",\n  \"locked\",\n  \"lower\",\n  \"match\",\n  \"max\",\n  \"merge\",\n  \"min\",\n  \"minute\",\n  \"module\",\n  \"month\",\n  \"names\",\n  \"national\",\n  \"natural\",\n  \"nchar\",\n  \"next\",\n  \"no\",\n  \"nocheck\",\n  \"nonclustered\",\n  \"none\",\n  \"not\",\n  \"nowait\",\n  \"null\",\n  \"nullif\",\n  \"numeric\",\n  \"octet_length\",\n  \"of\",\n  \"off\",\n  \"offset\",\n  \"offsets\",\n  \"on\",\n  \"only\",\n  \"open\",\n  \"opendatasource\",\n  \"openquery\",\n  \"openrowset\",\n  \"openxml\",\n  \"option\",\n  \"or\",\n  \"order\",\n  \"outer\",\n  \"output\",\n  \"over\",\n  \"overlaps\",\n  \"pad\",\n  \"partial\",\n  \"pascal\",\n  \"percent\",\n  \"pivot\",\n  \"plan\",\n  \"position\",\n  \"precision\",\n  \"prepare\",\n  \"preserve\",\n  \"primary\",\n  \"print\",\n  \"prior\",\n  \"privileges\",\n  \"proc\",\n  \"procedure\",\n  \"public\",\n  \"raiserror\",\n  \"read\",\n  \"readtext\",\n  \"real\",\n  \"reconfigure\",\n  \"references\",\n  \"relative\",\n  \"replication\",\n  \"restore\",\n  \"restrict\",\n  \"return\",\n  \"revert\",\n  \"revoke\",\n  \"right\",\n  \"right\",\n  \"rollback\",\n  \"row\",\n  \"rowcount\",\n  \"rowguidcol\",\n  \"rows\",\n  \"rule\",\n  \"save\",\n  \"schema\",\n  \"scroll\",\n  \"second\",\n  \"section\",\n  \"securityaudit\",\n  \"select\",\n  \"semantickeyphrasetable\",\n  \"semanticsimilaritydetailstable\",\n  \"semanticsimilaritytable\",\n  \"session_user\",\n  \"session\",\n  \"set\",\n  \"setuser\",\n  \"share\",\n  \"show\",\n  \"shutdown\",\n  \"size\",\n  \"skip\",\n  \"smallint\",\n  \"some\",\n  \"space\",\n  \"sql\",\n  \"sqlca\",\n  \"sqlcode\",\n  \"sqlerror\",\n  \"sqlstate\",\n  \"sqlwarning\",\n  \"statistics\",\n  \"substring\",\n  \"sum\",\n  \"system_user\",\n  \"table\",\n  \"tablesample\",\n  \"temporary\",\n  \"textsize\",\n  \"then\",\n  \"time\",\n  \"timestamp\",\n  \"timezone_hour\",\n  \"timezone_minute\",\n  \"to\",\n  \"top\",\n  \"trailing\",\n  \"tran\",\n  \"transaction\",\n  \"translate\",\n  \"translation\",\n  \"trigger\",\n  \"trim\",\n  \"true\",\n  \"truncate\",\n  \"try_convert\",\n  \"tsequal\",\n  \"union\",\n  \"unique\",\n  \"unknown\",\n  \"unpivot\",\n  \"update\",\n  \"updatetext\",\n  \"upper\",\n  \"usage\",\n  \"use\",\n  \"user\",\n  \"using\",\n  \"value\",\n  \"values\",\n  \"varchar\",\n  \"varying\",\n  \"view\",\n  \"waitfor\",\n  \"when\",\n  \"whenever\",\n  \"where\",\n  \"while\",\n  \"with\",\n  \"within group\",\n  \"work\",\n  \"write\",\n  \"writetext\",\n  \"year\",\n  \"zone\",\n];\n","const getStatements = require(\"./get-statements\");\n\n/**\n * Enforce limit/top on SQL SELECT queries.\n * Non SELECT queries will not be altered.\n * If existing limit exists, it will be lowered if it is larger than `limitNumber` specified\n * If limit does not exist, it will be added.\n * Returns SQL text with limits enforced.\n *\n * @param {string} sqlText - sql text to limit\n * @param {Array<String>|String} limitStrategies -- First strategy value takes priority if no limit exists\n * @param {number} limitNumber -- number to enforce for limit keyword\n * @returns {string}\n */\nfunction limit(sqlText, limitStrategies, limitNumber) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  if (typeof limitNumber !== \"number\") {\n    throw new Error(\"limitNumber must be number\");\n  }\n\n  let strategies =\n    typeof limitStrategies === \"string\" ? [limitStrategies] : limitStrategies;\n\n  if (!Array.isArray(strategies)) {\n    throw new Error(\"limitStrategies must be an array or string\");\n  }\n\n  if (strategies.length === 0) {\n    throw new Error(\"limitStrategies must not be empty\");\n  }\n\n  strategies = strategies.map((s) => s.toLowerCase());\n\n  return getStatements(sqlText)\n    .map((statement) => {\n      statement.enforceLimit(strategies, limitNumber);\n      return statement.toString();\n    })\n    .join(\"\");\n}\n\n/**\n * Splits SQL text on terminator, returning an array of SQL statements\n * @param {string} sqlText\n */\nfunction apiGetStatements(sqlText) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlText);\n  return statements.map((statement) => statement.toString());\n}\n\n/**\n * Removes terminator from SQL statement.\n * Only a single statement allowed.\n * Throws error if multiple statements are included\n * @param {string} sqlStatement\n */\nfunction removeTerminator(sqlStatement) {\n  if (typeof sqlStatement !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlStatement)\n    .map((s) => s.toString(true))\n    .filter((s) => s.trim() !== \"\");\n\n  if (statements.length > 1) {\n    throw new Error(\"Multiple statements detected\");\n  }\n\n  return statements[0];\n}\n\n/**\n * Gets statement type keyword from statement string (select, update, delete, etc)\n * Only a single statement allowed.\n * Throws error if multiple statements are included\n * @param {string} statementType\n */\nfunction getStatementType(sqlStatement) {\n  if (typeof sqlStatement !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statementObjects = getStatements(sqlStatement).filter(\n    (s) => s.toString().trim() !== \"\"\n  );\n\n  if (statementObjects.length > 1) {\n    throw new Error(\"Multiple statements detected\");\n  }\n\n  return statementObjects[0].getStatementType();\n}\n\nmodule.exports = {\n  getStatements: apiGetStatements,\n  getStatementType,\n  limit,\n  removeTerminator,\n};\n","/**\n * This library was modified by Harrison Liddiard. The source code to this\n * modified version can be found at https://github.com/liddiard/google-diff/.\n * The original source code can be found at\n * http://code.google.com/p/google-diff-match-patch/. This unofficial fork is\n * not maintained by or affiliated with Google Inc. The original attribution\n * and licensing information follows.\n */\n\n/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff.\n * @constructor\n */\nfunction diff(options) {\n  var options = options || {};\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Timeout = options.timeout || 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.EditCost = options.editCost || 4;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n */\ndiff.prototype.main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.lineMode_(text1, text2, deadline);\n  }\n\n  return this.bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.main(text1a, text2a, false, deadline);\n  var diffsb = this.main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff.prototype.linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff.prototype.charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff.prototype.commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff.prototype.commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff.prototype.commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff.prototype.halfMatch_ = function(text1, text2) {\n  if (this.Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.commonPrefix(longtext.substring(i),\n                                          shorttext.substring(j));\n      var suffixLength = dmp.commonSuffix(longtext.substring(0, i),\n                                          shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n  this.cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff.whitespaceRegex_ = /\\s/;\ndiff.linebreakRegex_ = /[\\r\\n]/;\ndiff.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff.prototype.xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff.prototype.prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_br = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_br, '<br/>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins>' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del>' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff.prototype.text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff.prototype.text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff.prototype.levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff.prototype.toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff.prototype.fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// Users of node.js should 'require' the uncompressed version since Google's\n// JS compiler may break the following exports for non-browser environments.\nthis['diff'] = diff;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\nmodule.exports = diff;\n","<script>\n  import sqlLimiter from \"../../src/index.js\";\n  import Diff from \"text-diff\";\n\n  export let sql = \"\";\n  export let strategies = [\"limit\"];\n  export let limitNumber = 100;\n\n  let diff = new Diff();\n  let limited = \"\";\n  let textDiff;\n  let prettyHtml;\n  let error;\n\n  $: try {\n    error = null;\n    limited = sqlLimiter.limit(sql, strategies, limitNumber);\n    textDiff = diff.main(sql, limited);\n    prettyHtml = diff.prettyHtml(textDiff);\n  } catch (e) {\n    error = e;\n  }\n</script>\n\n{#if error}\n  <span class=\"error\">{error}</span>\n{:else}\n  {@html prettyHtml}\n{/if}\n\n<style>\n  :global(ins) {\n    color: green;\n  }\n\n  :global(del) {\n    color: red;\n  }\n\n  .error {\n    color: red;\n  }\n</style>\n","<script>\n  export let value = \"\";\n  export let label = \"strategy\";\n</script>\n\n<label for={label}>{label}</label>\n<select id={label} class=\"input\" bind:value>\n  <option value=\"\">\n    <em>none</em>\n  </option>\n  <option value=\"fetch\">fetch</option>\n  <option value=\"first\">first</option>\n  <option value=\"limit\">limit</option>\n  <option value=\"top\">top</option>\n</select>\n\n<style>\n  label {\n    font-variant: small-caps;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n</style>\n","<script>\n  import Logo from \"./Logo.svelte\";\n  import SqlDiff from \"./SqlDiff.svelte\";\n  import Strategies from \"./Strategies.svelte\";\n\n  let strategy1 = \"limit\";\n  let strategy2 = \"fetch\";\n  let strategy3 = \"\";\n  let limitNumber = 100;\n  let original = `SELECT * FROM some_table;`;\n\n  $: limitStrategies = [strategy1, strategy2, strategy3].filter(\n    (s) => s !== \"\"\n  );\n</script>\n\n<main>\n  <Logo />\n  <div class=\"row\">\n    <div class=\"col-100 m8\">\n      <h1>sql-limiter</h1>\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"m8\">\n      <Strategies label=\"strategy 1\" bind:value={strategy1} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 2\" bind:value={strategy2} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 3\" bind:value={strategy3} />\n    </div>\n    <div class=\"m8\">\n      <label for=\"limit-number\">limit number</label>\n      <input\n        id=\"limit-number\"\n        class=\"input\"\n        type=\"number\"\n        bind:value={limitNumber}\n      />\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"col-50 m8\">\n      <label for=\"sql-in\">input</label>\n      <textarea id=\"sql-in\" class=\"sql\" rows=\"15\" bind:value={original} />\n    </div>\n    <div class=\"col-50 m8\">\n      <span class=\"fake-label\">result</span>\n      <pre\n        class=\"sql out\">\n        <SqlDiff sql={original} strategies={limitStrategies} {limitNumber} />\n      </pre>\n    </div>\n  </div>\n</main>\n\n<style>\n  h1 {\n    color: #ff3e00;\n    font-variant: small-caps;\n    text-transform: uppercase;\n    font-size: 2em;\n    font-weight: 100;\n  }\n\n  label {\n    font-variant: small-caps;\n  }\n\n  .row {\n    display: flex;\n  }\n\n  .m8 {\n    margin: 8px;\n  }\n\n  .col-100 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n  .col-50 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n\n  #sql-in {\n    white-space: pre;\n  }\n\n  /* consistent styling for textarea and not */\n  .sql {\n    border-radius: 2px;\n    border: 1px solid #ccc;\n    box-sizing: border-box;\n    font-family: monospace;\n    font-size: 14px;\n    margin: 0;\n    padding: 8px;\n    width: 100%;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n\n  .out {\n    overflow-x: auto;\n  }\n\n  .fake-label {\n    font-variant: small-caps;\n  }\n</style>\n","import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","to_number","set_data","wholeText","set_input_value","input","select_option","select","i","length","option","__value","selected","selectedIndex","HtmlTag","[object Object]","this","e","n","html","h","nodeName","t","c","innerHTML","Array","from","childNodes","d","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","add_flush_callback","flushing","seen_callbacks","Set","flush","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","transition_out","o","outros","bind","index","props","undefined","bound","create_component","mount_component","customElement","on_mount","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","append_styles","parent_component","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","children","l","intro","SvelteComponent","$destroy","type","indexOf","splice","$$props","obj","$$set","keys","factory","hasOwnProperty","prototype","toString","hasSticky","RegExp","sticky","isRegExp","call","isObject","isArray","reCapture","s","reUnion","regexps","join","regexpOrLiteral","replace","ignoreCase","Error","global","multiline","source","ruleOptions","match","include","defaultType","lineBreaks","error","fallback","next","shouldThrow","key","sort","toRules","spec","array","result","concat","j","JSON","stringify","arrayToRules","object","getOwnPropertyNames","rules","rule","objectToRules","defaultErrorRule","compileRules","hasStates","errorRule","fast","fastAllowed","unicodeFlag","groups","parts","slice","shift","charCodeAt","unicode","pat","regexp","test","exec","fallbackRule","flags","suffix","checkStateGroup","g","state","Lexer","states","startState","buffer","stack","reset","info","line","col","queuedToken","queuedThrow","setState","save","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","queuedGroup","token","_token","queuedText","group","charAt","lastIndex","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","start","Math","max","eol","firstLine","substring","clone","tokenType","compile","all","$all","ruleMap","included","newRules","k","newRule","apply","fastKeys","freeze","keywords","reverseMap","byLength","types","item","keyword","str","x","Function","exports","module","moo","createToken","singleSpace","toLowerCase","number","findToken","tokens","startingIndex","predicate","tokenUtils","level","queryTokens","targetParenLevel","require$$0","findParenLevelToken","findLimitInsertionIndex","nextNonCommentNonWhitespace","require$$1","fetch","fetchKeywordToken","nextNonWC","statementKeywordIndex","limit","insertBeforeToken","fetchToOnlyTokens","firstHalf","secondhalf","terminatorToken","targetIndex","firstKeywordToken","limitNumber","limitKeywordToken","firstNumber","possibleComma","secondNumber","topKeywordToken","strategies","first","require$$2","top","require$$3","Statement","parenLevel","statementToken","fetchToken","limitToken","strategiesToEnforce","toEnforce","numberToken","parseInt","preferredStrategy","stripTerminator","whitespace","comment","lparen","rparen","comma","period","terminator","quotedIdentifier","string","identifier","defs","defineKeywords","caseInsensitiveKeywords","operator","getStatements","sqlText","statements","statement","appendToken","src","getStatementType","sqlStatement","statementObjects","trim","limitStrategies","enforceLimit","removeTerminator","diff","Timeout","timeout","EditCost","editCost","DIFF_DELETE","main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","checklines","commonlength","commonPrefix","commonprefix","commonSuffix","commonsuffix","diffs","compute_","unshift","cleanupMerge","longtext","shorttext","hm","halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","lineMode_","bisect_","linesToChars_","chars1","chars2","linearray","lineArray","charsToLines_","cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","delta","front","k1start","k1end","k2start","k2end","k1","k1_offset","y1","x1","k2_offset","x2","bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","String","fromCharCode","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","xIndex","loc","last_chars1","last_chars2","prettyHtml","pattern_amp","pattern_lt","pattern_gt","pattern_br","op","levenshtein","insertions","deletions","toDelta","encodeURI","fromDelta","diffsLength","split","param","decodeURI","ex","isNaN","diff_1","textDiff","sql","Diff","limited","sqlLimiter","label","selected_option","querySelector","strategy1","strategy2","strategy3","original","body"],"mappings":"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AAMf,EAAYJ,GAChBV,EACA6B,EAAgB7N,MAAQ,GAG1B,IAAK8M,EACH,MAAM,IAAI5I,MAAM,+BAGlB,GAAuB,WAAnB4I,EAAUtK,KACZ,MAAM,IAAI0B,MAAM,uBAAuB4I,EAAUtK,QAGnD,OAAOsK,UAYT,SAAad,EAAQe,EAAuBT,EAAkBkB,GAE5D,MAAML,EAAYnB,EAAOxF,MAAM,EAAGuG,EAAwB,GACpDK,EAAapB,EAAOxF,MAAMuG,EAAwB,GACxD,MAAO,IACFI,EACHxB,GAAYC,cACZD,GAAYP,QAAQ,OACpBO,GAAYC,cACZD,GAAYG,OAAO0B,MAChBJ,ICxDP,MAAMU,GCIW,CACflB,MANYL,GAOZwB,MANYpB,SACAqB,GAOZC,IANUC,ICHZ,MAAMxC,GAAMa,UACNxB,GCDW,CACf,WACA,SACA,MACA,MACA,MACA,WACA,QACA,MACA,MACA,MACA,KACA,MACA,YACA,KACA,gBACA,MACA,SACA,QACA,UACA,aACA,MACA,OACA,QACA,SACA,OACA,KACA,UACA,WACA,OACA,OACA,UACA,cACA,OACA,mBACA,YACA,QACA,aACA,QACA,YACA,WACA,UACA,YACA,SACA,SACA,UACA,UACA,aACA,aACA,cACA,WACA,gBACA,WACA,UACA,gBACA,QACA,SACA,QACA,eACA,eACA,oBACA,eACA,UACA,SACA,WACA,OACA,MACA,OACA,aACA,MACA,UACA,UACA,UACA,aACA,WACA,SACA,OACA,OACA,WACA,aACA,cACA,aACA,OACA,WACA,cACA,SACA,SACA,OACA,OACA,OACA,WACA,MACA,SACA,SACA,SACA,YACA,OACA,UACA,SACA,OACA,WACA,UACA,QACA,QACA,OACA,aACA,QACA,QACA,MACA,UACA,UACA,QACA,WACA,gBACA,OACA,OACA,WACA,MACA,SACA,KACA,OACA,QACA,QACA,SACA,WACA,OACA,kBACA,WACA,cACA,KACA,YACA,KACA,UACA,QACA,YACA,YACA,QACA,QACA,cACA,SACA,MACA,UACA,YACA,WACA,OACA,KACA,YACA,OACA,MACA,OACA,WACA,OACA,UACA,OACA,QACA,OACA,QACA,SACA,OACA,QACA,SACA,QACA,QACA,MACA,QACA,MACA,SACA,SACA,QACA,QACA,WACA,UACA,QACA,OACA,KACA,UACA,eACA,OACA,MACA,SACA,OACA,SACA,UACA,eACA,KACA,MACA,SACA,UACA,KACA,OACA,OACA,iBACA,YACA,aACA,UACA,SACA,KACA,QACA,QACA,SACA,OACA,WACA,MACA,UACA,SACA,UACA,QACA,OACA,WACA,YACA,UACA,WACA,UACA,QACA,QACA,aACA,OACA,YACA,SACA,YACA,OACA,WACA,OACA,cACA,aACA,WACA,cACA,UACA,WACA,SACA,SACA,SACA,QACA,QACA,WACA,MACA,WACA,aACA,OACA,OACA,OACA,SACA,SACA,SACA,UACA,gBACA,SACA,yBACA,iCACA,0BACA,eACA,UACA,MACA,UACA,QACA,OACA,WACA,OACA,OACA,WACA,OACA,QACA,MACA,QACA,UACA,WACA,WACA,aACA,aACA,YACA,MACA,cACA,QACA,cACA,YACA,WACA,OACA,OACA,YACA,gBACA,kBACA,KACA,MACA,WACA,OACA,cACA,YACA,cACA,UACA,OACA,OACA,WACA,cACA,UACA,QACA,SACA,UACA,UACA,SACA,aACA,QACA,QACA,MACA,OACA,QACA,QACA,SACA,UACA,UACA,OACA,UACA,OACA,WACA,QACA,QACA,OACA,eACA,OACA,QACA,YACA,OACA,QD/TIoD,GFCN,MACEzR,cACEC,KAAKqP,OAAS,GACdrP,KAAKyR,WAAa,EAClBzR,KAAK2P,iBAAmB,KACxB3P,KAAK0R,eAAiB,KACtB1R,KAAK2R,WAAa,KAClB3R,KAAK4R,WAAa,KAQpB7R,mBACE,GAAIC,KAAK0R,eACP,OAAO1R,KAAK0R,eAAe7S,MAK/BkB,YAAYO,GACV,MAAM0L,EAAQ,IAAK1L,GACnB0L,EAAMyF,WAAazR,KAAKyR,WAExBzF,EAAM3I,MAAQrD,KAAKqP,OAAO5P,OAC1BO,KAAKqP,OAAO5N,KAAKuK,GAEE,WAAfA,EAAMn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"}